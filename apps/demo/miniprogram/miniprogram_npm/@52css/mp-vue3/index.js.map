{"version":3,"sources":["mp-vue3.min.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.MpVue3 = {}));\n})(this, (function (exports) { \n\n  /**\n  * @vue/shared v3.4.35\n  * (c) 2018-present Yuxi (Evan) You and Vue contributors\n  * @license MIT\n  **/\n  /*! #__NO_SIDE_EFFECTS__ */\n  // @__NO_SIDE_EFFECTS__\n  function makeMap(str, expectsLowerCase) {\n    const set = new Set(str.split(\",\"));\n    return (val) => set.has(val);\n  }\n  const NOOP$1 = () => {\n  };\n  const extend = Object.assign;\n  const hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n  const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);\n  const isArray$1 = Array.isArray;\n  const isMap$1 = (val) => toTypeString(val) === \"[object Map]\";\n  const isFunction$1 = (val) => typeof val === \"function\";\n  const isString = (val) => typeof val === \"string\";\n  const isSymbol = (val) => typeof val === \"symbol\";\n  const isObject$1 = (val) => val !== null && typeof val === \"object\";\n  const objectToString = Object.prototype.toString;\n  const toTypeString = (value) => objectToString.call(value);\n  const toRawType = (value) => {\n    return toTypeString(value).slice(8, -1);\n  };\n  const isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\n  const hasChanged$1 = (value, oldValue) => !Object.is(value, oldValue);\n  const def = (obj, key, value, writable = false) => {\n    Object.defineProperty(obj, key, {\n      configurable: true,\n      enumerable: false,\n      writable,\n      value\n    });\n  };\n\n  /**\n  * @vue/reactivity v3.4.35\n  * (c) 2018-present Yuxi (Evan) You and Vue contributors\n  * @license MIT\n  **/\n\n  let activeEffectScope;\n  class EffectScope {\n    constructor(detached = false) {\n      this.detached = detached;\n      /**\n       * @internal\n       */\n      this._active = true;\n      /**\n       * @internal\n       */\n      this.effects = [];\n      /**\n       * @internal\n       */\n      this.cleanups = [];\n      this.parent = activeEffectScope;\n      if (!detached && activeEffectScope) {\n        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n          this\n        ) - 1;\n      }\n    }\n    get active() {\n      return this._active;\n    }\n    run(fn) {\n      if (this._active) {\n        const currentEffectScope = activeEffectScope;\n        try {\n          activeEffectScope = this;\n          return fn();\n        } finally {\n          activeEffectScope = currentEffectScope;\n        }\n      }\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    on() {\n      activeEffectScope = this;\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    off() {\n      activeEffectScope = this.parent;\n    }\n    stop(fromParent) {\n      if (this._active) {\n        let i, l;\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].stop();\n        }\n        for (i = 0, l = this.cleanups.length; i < l; i++) {\n          this.cleanups[i]();\n        }\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].stop(true);\n          }\n        }\n        if (!this.detached && this.parent && !fromParent) {\n          const last = this.parent.scopes.pop();\n          if (last && last !== this) {\n            this.parent.scopes[this.index] = last;\n            last.index = this.index;\n          }\n        }\n        this.parent = void 0;\n        this._active = false;\n      }\n    }\n  }\n  function effectScope(detached) {\n    return new EffectScope(detached);\n  }\n  function recordEffectScope(effect, scope = activeEffectScope) {\n    if (scope && scope.active) {\n      scope.effects.push(effect);\n    }\n  }\n  function getCurrentScope() {\n    return activeEffectScope;\n  }\n  function onScopeDispose(fn) {\n    if (activeEffectScope) {\n      activeEffectScope.cleanups.push(fn);\n    }\n  }\n\n  let activeEffect;\n  class ReactiveEffect {\n    constructor(fn, trigger, scheduler, scope) {\n      this.fn = fn;\n      this.trigger = trigger;\n      this.scheduler = scheduler;\n      this.active = true;\n      this.deps = [];\n      /**\n       * @internal\n       */\n      this._dirtyLevel = 4;\n      /**\n       * @internal\n       */\n      this._trackId = 0;\n      /**\n       * @internal\n       */\n      this._runnings = 0;\n      /**\n       * @internal\n       */\n      this._shouldSchedule = false;\n      /**\n       * @internal\n       */\n      this._depsLength = 0;\n      recordEffectScope(this, scope);\n    }\n    get dirty() {\n      if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {\n        this._dirtyLevel = 1;\n        pauseTracking();\n        for (let i = 0; i < this._depsLength; i++) {\n          const dep = this.deps[i];\n          if (dep.computed) {\n            triggerComputed(dep.computed);\n            if (this._dirtyLevel >= 4) {\n              break;\n            }\n          }\n        }\n        if (this._dirtyLevel === 1) {\n          this._dirtyLevel = 0;\n        }\n        resetTracking();\n      }\n      return this._dirtyLevel >= 4;\n    }\n    set dirty(v) {\n      this._dirtyLevel = v ? 4 : 0;\n    }\n    run() {\n      this._dirtyLevel = 0;\n      if (!this.active) {\n        return this.fn();\n      }\n      let lastShouldTrack = shouldTrack;\n      let lastEffect = activeEffect;\n      try {\n        shouldTrack = true;\n        activeEffect = this;\n        this._runnings++;\n        preCleanupEffect(this);\n        return this.fn();\n      } finally {\n        postCleanupEffect(this);\n        this._runnings--;\n        activeEffect = lastEffect;\n        shouldTrack = lastShouldTrack;\n      }\n    }\n    stop() {\n      if (this.active) {\n        preCleanupEffect(this);\n        postCleanupEffect(this);\n        this.onStop && this.onStop();\n        this.active = false;\n      }\n    }\n  }\n  function triggerComputed(computed) {\n    return computed.value;\n  }\n  function preCleanupEffect(effect2) {\n    effect2._trackId++;\n    effect2._depsLength = 0;\n  }\n  function postCleanupEffect(effect2) {\n    if (effect2.deps.length > effect2._depsLength) {\n      for (let i = effect2._depsLength; i < effect2.deps.length; i++) {\n        cleanupDepEffect(effect2.deps[i], effect2);\n      }\n      effect2.deps.length = effect2._depsLength;\n    }\n  }\n  function cleanupDepEffect(dep, effect2) {\n    const trackId = dep.get(effect2);\n    if (trackId !== void 0 && effect2._trackId !== trackId) {\n      dep.delete(effect2);\n      if (dep.size === 0) {\n        dep.cleanup();\n      }\n    }\n  }\n  function effect(fn, options) {\n    if (fn.effect instanceof ReactiveEffect) {\n      fn = fn.effect.fn;\n    }\n    const _effect = new ReactiveEffect(fn, NOOP$1, () => {\n      if (_effect.dirty) {\n        _effect.run();\n      }\n    });\n    if (options) {\n      extend(_effect, options);\n      if (options.scope) recordEffectScope(_effect, options.scope);\n    }\n    if (!options || !options.lazy) {\n      _effect.run();\n    }\n    const runner = _effect.run.bind(_effect);\n    runner.effect = _effect;\n    return runner;\n  }\n  function stop(runner) {\n    runner.effect.stop();\n  }\n  let shouldTrack = true;\n  let pauseScheduleStack = 0;\n  const trackStack = [];\n  function pauseTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = false;\n  }\n  function resetTracking() {\n    const last = trackStack.pop();\n    shouldTrack = last === void 0 ? true : last;\n  }\n  function pauseScheduling() {\n    pauseScheduleStack++;\n  }\n  function resetScheduling() {\n    pauseScheduleStack--;\n    while (!pauseScheduleStack && queueEffectSchedulers.length) {\n      queueEffectSchedulers.shift()();\n    }\n  }\n  function trackEffect(effect2, dep, debuggerEventExtraInfo) {\n    if (dep.get(effect2) !== effect2._trackId) {\n      dep.set(effect2, effect2._trackId);\n      const oldDep = effect2.deps[effect2._depsLength];\n      if (oldDep !== dep) {\n        if (oldDep) {\n          cleanupDepEffect(oldDep, effect2);\n        }\n        effect2.deps[effect2._depsLength++] = dep;\n      } else {\n        effect2._depsLength++;\n      }\n    }\n  }\n  const queueEffectSchedulers = [];\n  function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {\n    pauseScheduling();\n    for (const effect2 of dep.keys()) {\n      let tracking;\n      if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {\n        effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);\n        effect2._dirtyLevel = dirtyLevel;\n      }\n      if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {\n        effect2.trigger();\n        if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {\n          effect2._shouldSchedule = false;\n          if (effect2.scheduler) {\n            queueEffectSchedulers.push(effect2.scheduler);\n          }\n        }\n      }\n    }\n    resetScheduling();\n  }\n\n  const createDep = (cleanup, computed) => {\n    const dep = /* @__PURE__ */ new Map();\n    dep.cleanup = cleanup;\n    dep.computed = computed;\n    return dep;\n  };\n\n  const targetMap = /* @__PURE__ */ new WeakMap();\n  const ITERATE_KEY = Symbol(\"\");\n  const MAP_KEY_ITERATE_KEY = Symbol(\"\");\n  function track(target, type, key) {\n    if (shouldTrack && activeEffect) {\n      let depsMap = targetMap.get(target);\n      if (!depsMap) {\n        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n      }\n      let dep = depsMap.get(key);\n      if (!dep) {\n        depsMap.set(key, dep = createDep(() => depsMap.delete(key)));\n      }\n      trackEffect(\n        activeEffect,\n        dep);\n    }\n  }\n  function trigger(target, type, key, newValue, oldValue, oldTarget) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n      return;\n    }\n    let deps = [];\n    if (type === \"clear\") {\n      deps = [...depsMap.values()];\n    } else if (key === \"length\" && isArray$1(target)) {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || !isSymbol(key2) && key2 >= newLength) {\n          deps.push(dep);\n        }\n      });\n    } else {\n      if (key !== void 0) {\n        deps.push(depsMap.get(key));\n      }\n      switch (type) {\n        case \"add\":\n          if (!isArray$1(target)) {\n            deps.push(depsMap.get(ITERATE_KEY));\n            if (isMap$1(target)) {\n              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isIntegerKey(key)) {\n            deps.push(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!isArray$1(target)) {\n            deps.push(depsMap.get(ITERATE_KEY));\n            if (isMap$1(target)) {\n              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap$1(target)) {\n            deps.push(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n    pauseScheduling();\n    for (const dep of deps) {\n      if (dep) {\n        triggerEffects(\n          dep,\n          4);\n      }\n    }\n    resetScheduling();\n  }\n  function getDepFromReactive(object, key) {\n    const depsMap = targetMap.get(object);\n    return depsMap && depsMap.get(key);\n  }\n\n  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\n  const builtInSymbols = new Set(\n    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n  );\n  const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();\n  function createArrayInstrumentations() {\n    const instrumentations = {};\n    [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n      instrumentations[key] = function(...args) {\n        const arr = toRaw(this);\n        for (let i = 0, l = this.length; i < l; i++) {\n          track(arr, \"get\", i + \"\");\n        }\n        const res = arr[key](...args);\n        if (res === -1 || res === false) {\n          return arr[key](...args.map(toRaw));\n        } else {\n          return res;\n        }\n      };\n    });\n    [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n      instrumentations[key] = function(...args) {\n        pauseTracking();\n        pauseScheduling();\n        const res = toRaw(this)[key].apply(this, args);\n        resetScheduling();\n        resetTracking();\n        return res;\n      };\n    });\n    return instrumentations;\n  }\n  function hasOwnProperty(key) {\n    if (!isSymbol(key)) key = String(key);\n    const obj = toRaw(this);\n    track(obj, \"has\", key);\n    return obj.hasOwnProperty(key);\n  }\n  class BaseReactiveHandler {\n    constructor(_isReadonly = false, _isShallow = false) {\n      this._isReadonly = _isReadonly;\n      this._isShallow = _isShallow;\n    }\n    get(target, key, receiver) {\n      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n      if (key === \"__v_isReactive\") {\n        return !isReadonly2;\n      } else if (key === \"__v_isReadonly\") {\n        return isReadonly2;\n      } else if (key === \"__v_isShallow\") {\n        return isShallow2;\n      } else if (key === \"__v_raw\") {\n        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n        // this means the reciever is a user proxy of the reactive proxy\n        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n          return target;\n        }\n        return;\n      }\n      const targetIsArray = isArray$1(target);\n      if (!isReadonly2) {\n        if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n          return Reflect.get(arrayInstrumentations, key, receiver);\n        }\n        if (key === \"hasOwnProperty\") {\n          return hasOwnProperty;\n        }\n      }\n      const res = Reflect.get(target, key, receiver);\n      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n        return res;\n      }\n      if (!isReadonly2) {\n        track(target, \"get\", key);\n      }\n      if (isShallow2) {\n        return res;\n      }\n      if (isRef(res)) {\n        return targetIsArray && isIntegerKey(key) ? res : res.value;\n      }\n      if (isObject$1(res)) {\n        return isReadonly2 ? readonly(res) : reactive(res);\n      }\n      return res;\n    }\n  }\n  class MutableReactiveHandler extends BaseReactiveHandler {\n    constructor(isShallow2 = false) {\n      super(false, isShallow2);\n    }\n    set(target, key, value, receiver) {\n      let oldValue = target[key];\n      if (!this._isShallow) {\n        const isOldValueReadonly = isReadonly(oldValue);\n        if (!isShallow(value) && !isReadonly(value)) {\n          oldValue = toRaw(oldValue);\n          value = toRaw(value);\n        }\n        if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {\n          if (isOldValueReadonly) {\n            return false;\n          } else {\n            oldValue.value = value;\n            return true;\n          }\n        }\n      }\n      const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n      const result = Reflect.set(target, key, value, receiver);\n      if (target === toRaw(receiver)) {\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (hasChanged$1(value, oldValue)) {\n          trigger(target, \"set\", key, value);\n        }\n      }\n      return result;\n    }\n    deleteProperty(target, key) {\n      const hadKey = hasOwn(target, key);\n      target[key];\n      const result = Reflect.deleteProperty(target, key);\n      if (result && hadKey) {\n        trigger(target, \"delete\", key, void 0);\n      }\n      return result;\n    }\n    has(target, key) {\n      const result = Reflect.has(target, key);\n      if (!isSymbol(key) || !builtInSymbols.has(key)) {\n        track(target, \"has\", key);\n      }\n      return result;\n    }\n    ownKeys(target) {\n      track(\n        target,\n        \"iterate\",\n        isArray$1(target) ? \"length\" : ITERATE_KEY\n      );\n      return Reflect.ownKeys(target);\n    }\n  }\n  class ReadonlyReactiveHandler extends BaseReactiveHandler {\n    constructor(isShallow2 = false) {\n      super(true, isShallow2);\n    }\n    set(target, key) {\n      return true;\n    }\n    deleteProperty(target, key) {\n      return true;\n    }\n  }\n  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\n  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\n  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(\n    true\n  );\n  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\n  const toShallow = (value) => value;\n  const getProto = (v) => Reflect.getPrototypeOf(v);\n  function get(target, key, isReadonly2 = false, isShallow2 = false) {\n    target = target[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (!isReadonly2) {\n      if (hasChanged$1(key, rawKey)) {\n        track(rawTarget, \"get\", key);\n      }\n      track(rawTarget, \"get\", rawKey);\n    }\n    const { has: has2 } = getProto(rawTarget);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    if (has2.call(rawTarget, key)) {\n      return wrap(target.get(key));\n    } else if (has2.call(rawTarget, rawKey)) {\n      return wrap(target.get(rawKey));\n    } else if (target !== rawTarget) {\n      target.get(key);\n    }\n  }\n  function has(key, isReadonly2 = false) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (!isReadonly2) {\n      if (hasChanged$1(key, rawKey)) {\n        track(rawTarget, \"has\", key);\n      }\n      track(rawTarget, \"has\", rawKey);\n    }\n    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n  }\n  function size(target, isReadonly2 = false) {\n    target = target[\"__v_raw\"];\n    !isReadonly2 && track(toRaw(target), \"iterate\", ITERATE_KEY);\n    return Reflect.get(target, \"size\", target);\n  }\n  function add(value, _isShallow = false) {\n    if (!_isShallow && !isShallow(value) && !isReadonly(value)) {\n      value = toRaw(value);\n    }\n    const target = toRaw(this);\n    const proto = getProto(target);\n    const hadKey = proto.has.call(target, value);\n    if (!hadKey) {\n      target.add(value);\n      trigger(target, \"add\", value, value);\n    }\n    return this;\n  }\n  function set(key, value, _isShallow = false) {\n    if (!_isShallow && !isShallow(value) && !isReadonly(value)) {\n      value = toRaw(value);\n    }\n    const target = toRaw(this);\n    const { has: has2, get: get2 } = getProto(target);\n    let hadKey = has2.call(target, key);\n    if (!hadKey) {\n      key = toRaw(key);\n      hadKey = has2.call(target, key);\n    }\n    const oldValue = get2.call(target, key);\n    target.set(key, value);\n    if (!hadKey) {\n      trigger(target, \"add\", key, value);\n    } else if (hasChanged$1(value, oldValue)) {\n      trigger(target, \"set\", key, value);\n    }\n    return this;\n  }\n  function deleteEntry(key) {\n    const target = toRaw(this);\n    const { has: has2, get: get2 } = getProto(target);\n    let hadKey = has2.call(target, key);\n    if (!hadKey) {\n      key = toRaw(key);\n      hadKey = has2.call(target, key);\n    }\n    get2 ? get2.call(target, key) : void 0;\n    const result = target.delete(key);\n    if (hadKey) {\n      trigger(target, \"delete\", key, void 0);\n    }\n    return result;\n  }\n  function clear() {\n    const target = toRaw(this);\n    const hadItems = target.size !== 0;\n    const result = target.clear();\n    if (hadItems) {\n      trigger(target, \"clear\", void 0, void 0);\n    }\n    return result;\n  }\n  function createForEach(isReadonly2, isShallow2) {\n    return function forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n      !isReadonly2 && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    };\n  }\n  function createIterableMethod(method, isReadonly2, isShallow2) {\n    return function(...args) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const targetIsMap = isMap$1(rawTarget);\n      const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n      const isKeyOnly = method === \"keys\" && targetIsMap;\n      const innerIterator = target[method](...args);\n      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n      !isReadonly2 && track(\n        rawTarget,\n        \"iterate\",\n        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n      );\n      return {\n        // iterator protocol\n        next() {\n          const { value, done } = innerIterator.next();\n          return done ? { value, done } : {\n            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n            done\n          };\n        },\n        // iterable protocol\n        [Symbol.iterator]() {\n          return this;\n        }\n      };\n    };\n  }\n  function createReadonlyMethod(type) {\n    return function(...args) {\n      return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n    };\n  }\n  function createInstrumentations() {\n    const mutableInstrumentations2 = {\n      get(key) {\n        return get(this, key);\n      },\n      get size() {\n        return size(this);\n      },\n      has,\n      add,\n      set,\n      delete: deleteEntry,\n      clear,\n      forEach: createForEach(false, false)\n    };\n    const shallowInstrumentations2 = {\n      get(key) {\n        return get(this, key, false, true);\n      },\n      get size() {\n        return size(this);\n      },\n      has,\n      add(value) {\n        return add.call(this, value, true);\n      },\n      set(key, value) {\n        return set.call(this, key, value, true);\n      },\n      delete: deleteEntry,\n      clear,\n      forEach: createForEach(false, true)\n    };\n    const readonlyInstrumentations2 = {\n      get(key) {\n        return get(this, key, true);\n      },\n      get size() {\n        return size(this, true);\n      },\n      has(key) {\n        return has.call(this, key, true);\n      },\n      add: createReadonlyMethod(\"add\"),\n      set: createReadonlyMethod(\"set\"),\n      delete: createReadonlyMethod(\"delete\"),\n      clear: createReadonlyMethod(\"clear\"),\n      forEach: createForEach(true, false)\n    };\n    const shallowReadonlyInstrumentations2 = {\n      get(key) {\n        return get(this, key, true, true);\n      },\n      get size() {\n        return size(this, true);\n      },\n      has(key) {\n        return has.call(this, key, true);\n      },\n      add: createReadonlyMethod(\"add\"),\n      set: createReadonlyMethod(\"set\"),\n      delete: createReadonlyMethod(\"delete\"),\n      clear: createReadonlyMethod(\"clear\"),\n      forEach: createForEach(true, true)\n    };\n    const iteratorMethods = [\n      \"keys\",\n      \"values\",\n      \"entries\",\n      Symbol.iterator\n    ];\n    iteratorMethods.forEach((method) => {\n      mutableInstrumentations2[method] = createIterableMethod(method, false, false);\n      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);\n      shallowInstrumentations2[method] = createIterableMethod(method, false, true);\n      shallowReadonlyInstrumentations2[method] = createIterableMethod(\n        method,\n        true,\n        true\n      );\n    });\n    return [\n      mutableInstrumentations2,\n      readonlyInstrumentations2,\n      shallowInstrumentations2,\n      shallowReadonlyInstrumentations2\n    ];\n  }\n  const [\n    mutableInstrumentations,\n    readonlyInstrumentations,\n    shallowInstrumentations,\n    shallowReadonlyInstrumentations\n  ] = /* @__PURE__ */ createInstrumentations();\n  function createInstrumentationGetter(isReadonly2, shallow) {\n    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;\n    return (target, key, receiver) => {\n      if (key === \"__v_isReactive\") {\n        return !isReadonly2;\n      } else if (key === \"__v_isReadonly\") {\n        return isReadonly2;\n      } else if (key === \"__v_raw\") {\n        return target;\n      }\n      return Reflect.get(\n        hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n        key,\n        receiver\n      );\n    };\n  }\n  const mutableCollectionHandlers = {\n    get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n  };\n  const shallowCollectionHandlers = {\n    get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n  };\n  const readonlyCollectionHandlers = {\n    get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n  };\n  const shallowReadonlyCollectionHandlers = {\n    get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n  };\n\n  const reactiveMap = /* @__PURE__ */ new WeakMap();\n  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();\n  const readonlyMap = /* @__PURE__ */ new WeakMap();\n  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\n  function targetTypeMap(rawType) {\n    switch (rawType) {\n      case \"Object\":\n      case \"Array\":\n        return 1 /* COMMON */;\n      case \"Map\":\n      case \"Set\":\n      case \"WeakMap\":\n      case \"WeakSet\":\n        return 2 /* COLLECTION */;\n      default:\n        return 0 /* INVALID */;\n    }\n  }\n  function getTargetType(value) {\n    return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n  }\n  function reactive(target) {\n    if (isReadonly(target)) {\n      return target;\n    }\n    return createReactiveObject(\n      target,\n      false,\n      mutableHandlers,\n      mutableCollectionHandlers,\n      reactiveMap\n    );\n  }\n  function shallowReactive(target) {\n    return createReactiveObject(\n      target,\n      false,\n      shallowReactiveHandlers,\n      shallowCollectionHandlers,\n      shallowReactiveMap\n    );\n  }\n  function readonly(target) {\n    return createReactiveObject(\n      target,\n      true,\n      readonlyHandlers,\n      readonlyCollectionHandlers,\n      readonlyMap\n    );\n  }\n  function shallowReadonly(target) {\n    return createReactiveObject(\n      target,\n      true,\n      shallowReadonlyHandlers,\n      shallowReadonlyCollectionHandlers,\n      shallowReadonlyMap\n    );\n  }\n  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n    if (!isObject$1(target)) {\n      return target;\n    }\n    if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n      return target;\n    }\n    const existingProxy = proxyMap.get(target);\n    if (existingProxy) {\n      return existingProxy;\n    }\n    const targetType = getTargetType(target);\n    if (targetType === 0 /* INVALID */) {\n      return target;\n    }\n    const proxy = new Proxy(\n      target,\n      targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n    );\n    proxyMap.set(target, proxy);\n    return proxy;\n  }\n  function isReactive(value) {\n    if (isReadonly(value)) {\n      return isReactive(value[\"__v_raw\"]);\n    }\n    return !!(value && value[\"__v_isReactive\"]);\n  }\n  function isReadonly(value) {\n    return !!(value && value[\"__v_isReadonly\"]);\n  }\n  function isShallow(value) {\n    return !!(value && value[\"__v_isShallow\"]);\n  }\n  function isProxy(value) {\n    return value ? !!value[\"__v_raw\"] : false;\n  }\n  function toRaw(observed) {\n    const raw = observed && observed[\"__v_raw\"];\n    return raw ? toRaw(raw) : observed;\n  }\n  function markRaw(value) {\n    if (Object.isExtensible(value)) {\n      def(value, \"__v_skip\", true);\n    }\n    return value;\n  }\n  const toReactive = (value) => isObject$1(value) ? reactive(value) : value;\n  const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;\n  class ComputedRefImpl {\n    constructor(getter, _setter, isReadonly, isSSR) {\n      this.getter = getter;\n      this._setter = _setter;\n      this.dep = void 0;\n      this.__v_isRef = true;\n      this[\"__v_isReadonly\"] = false;\n      this.effect = new ReactiveEffect(\n        () => getter(this._value),\n        () => triggerRefValue(\n          this,\n          this.effect._dirtyLevel === 2 ? 2 : 3\n        )\n      );\n      this.effect.computed = this;\n      this.effect.active = this._cacheable = !isSSR;\n      this[\"__v_isReadonly\"] = isReadonly;\n    }\n    get value() {\n      const self = toRaw(this);\n      if ((!self._cacheable || self.effect.dirty) && hasChanged$1(self._value, self._value = self.effect.run())) {\n        triggerRefValue(self, 4);\n      }\n      trackRefValue(self);\n      if (self.effect._dirtyLevel >= 2) {\n        triggerRefValue(self, 2);\n      }\n      return self._value;\n    }\n    set value(newValue) {\n      this._setter(newValue);\n    }\n    // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x\n    get _dirty() {\n      return this.effect.dirty;\n    }\n    set _dirty(v) {\n      this.effect.dirty = v;\n    }\n    // #endregion\n  }\n  function computed(getterOrOptions, debugOptions, isSSR = false) {\n    let getter;\n    let setter;\n    const onlyGetter = isFunction$1(getterOrOptions);\n    if (onlyGetter) {\n      getter = getterOrOptions;\n      setter = NOOP$1;\n    } else {\n      getter = getterOrOptions.get;\n      setter = getterOrOptions.set;\n    }\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n    return cRef;\n  }\n\n  function trackRefValue(ref2) {\n    var _a;\n    if (shouldTrack && activeEffect) {\n      ref2 = toRaw(ref2);\n      trackEffect(\n        activeEffect,\n        (_a = ref2.dep) != null ? _a : ref2.dep = createDep(\n          () => ref2.dep = void 0,\n          ref2 instanceof ComputedRefImpl ? ref2 : void 0\n        ));\n    }\n  }\n  function triggerRefValue(ref2, dirtyLevel = 4, newVal, oldVal) {\n    ref2 = toRaw(ref2);\n    const dep = ref2.dep;\n    if (dep) {\n      triggerEffects(\n        dep,\n        dirtyLevel);\n    }\n  }\n  function isRef(r) {\n    return !!(r && r.__v_isRef === true);\n  }\n  function ref(value) {\n    return createRef(value, false);\n  }\n  function shallowRef(value) {\n    return createRef(value, true);\n  }\n  function createRef(rawValue, shallow) {\n    if (isRef(rawValue)) {\n      return rawValue;\n    }\n    return new RefImpl(rawValue, shallow);\n  }\n  class RefImpl {\n    constructor(value, __v_isShallow) {\n      this.__v_isShallow = __v_isShallow;\n      this.dep = void 0;\n      this.__v_isRef = true;\n      this._rawValue = __v_isShallow ? value : toRaw(value);\n      this._value = __v_isShallow ? value : toReactive(value);\n    }\n    get value() {\n      trackRefValue(this);\n      return this._value;\n    }\n    set value(newVal) {\n      const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n      newVal = useDirectValue ? newVal : toRaw(newVal);\n      if (hasChanged$1(newVal, this._rawValue)) {\n        this._rawValue;\n        this._rawValue = newVal;\n        this._value = useDirectValue ? newVal : toReactive(newVal);\n        triggerRefValue(this, 4);\n      }\n    }\n  }\n  function triggerRef(ref2) {\n    triggerRefValue(ref2, 4);\n  }\n  function unref(ref2) {\n    return isRef(ref2) ? ref2.value : ref2;\n  }\n  function toValue(source) {\n    return isFunction$1(source) ? source() : unref(source);\n  }\n  const shallowUnwrapHandlers = {\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n    set: (target, key, value, receiver) => {\n      const oldValue = target[key];\n      if (isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      } else {\n        return Reflect.set(target, key, value, receiver);\n      }\n    }\n  };\n  function proxyRefs(objectWithRefs) {\n    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n  }\n  class CustomRefImpl {\n    constructor(factory) {\n      this.dep = void 0;\n      this.__v_isRef = true;\n      const { get, set } = factory(\n        () => trackRefValue(this),\n        () => triggerRefValue(this)\n      );\n      this._get = get;\n      this._set = set;\n    }\n    get value() {\n      return this._get();\n    }\n    set value(newVal) {\n      this._set(newVal);\n    }\n  }\n  function customRef(factory) {\n    return new CustomRefImpl(factory);\n  }\n  function toRefs(object) {\n    const ret = isArray$1(object) ? new Array(object.length) : {};\n    for (const key in object) {\n      ret[key] = propertyToRef(object, key);\n    }\n    return ret;\n  }\n  class ObjectRefImpl {\n    constructor(_object, _key, _defaultValue) {\n      this._object = _object;\n      this._key = _key;\n      this._defaultValue = _defaultValue;\n      this.__v_isRef = true;\n    }\n    get value() {\n      const val = this._object[this._key];\n      return val === void 0 ? this._defaultValue : val;\n    }\n    set value(newVal) {\n      this._object[this._key] = newVal;\n    }\n    get dep() {\n      return getDepFromReactive(toRaw(this._object), this._key);\n    }\n  }\n  class GetterRefImpl {\n    constructor(_getter) {\n      this._getter = _getter;\n      this.__v_isRef = true;\n      this.__v_isReadonly = true;\n    }\n    get value() {\n      return this._getter();\n    }\n  }\n  function toRef(source, key, defaultValue) {\n    if (isRef(source)) {\n      return source;\n    } else if (isFunction$1(source)) {\n      return new GetterRefImpl(source);\n    } else if (isObject$1(source) && arguments.length > 1) {\n      return propertyToRef(source, key, defaultValue);\n    } else {\n      return ref(source);\n    }\n  }\n  function propertyToRef(source, key, defaultValue) {\n    const val = source[key];\n    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n  }\n  const ReactiveFlags = {\n    \"SKIP\": \"__v_skip\",\n    \"IS_REACTIVE\": \"__v_isReactive\",\n    \"IS_READONLY\": \"__v_isReadonly\",\n    \"IS_SHALLOW\": \"__v_isShallow\",\n    \"RAW\": \"__v_raw\"\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  const NOOP = () => { };\n  const { isArray } = Array;\n  function getType(x) {\n      return Object.prototype.toString.call(x).slice(8, -1);\n  }\n  function isSimpleValue(x) {\n      const simpleTypes = new Set([\"undefined\", \"boolean\", \"number\", \"string\"]);\n      return x === null || simpleTypes.has(typeof x);\n  }\n  function isObject(x) {\n      return x !== null && typeof x === \"object\";\n  }\n  function isPlainObject(x) {\n      return getType(x) === \"Object\";\n  }\n  function isFunction(x) {\n      return typeof x === \"function\";\n  }\n  function isMap(x) {\n      return getType(x) === \"Map\";\n  }\n  function isSet(x) {\n      return getType(x) === \"Set\";\n  }\n  // Compare whether a value has changed, accounting for NaN.\n  function hasChanged(value, oldValue) {\n      // eslint-disable-next-line no-self-compare\n      return value !== oldValue && (value === value || oldValue === oldValue);\n  }\n  function remove(arr, el) {\n      const i = arr.indexOf(el);\n      if (i > -1) {\n          arr.splice(i, 1);\n      }\n  }\n\n  var __DEV__ = false;\n  let isFlushing = false;\n  let isFlushPending = false;\n  const queue = [];\n  let flushIndex = 0;\n  const pendingPostFlushCbs = [];\n  let activePostFlushCbs = null;\n  let postFlushIndex = 0;\n  // eslint-disable-next-line spaced-comment\n  const resolvedPromise = /*#__PURE__*/ Promise.resolve();\n  function queueJob(job) {\n      // The dedupe search uses the startIndex argument of Array.includes()\n      // by default the search index includes the current job that is being run\n      // so it cannot recursively trigger itself again.\n      // if the job is a watch() callback, the search will start with a +1 index to\n      // allow it recursively trigger itself - it is the user's responsibility to\n      // ensure it doesn't end up in an infinite loop.\n      if (queue.length === 0 ||\n          !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {\n          queue.push(job);\n          queueFlush();\n      }\n  }\n  function queueFlush() {\n      if (!isFlushing && !isFlushPending) {\n          isFlushPending = true;\n          // eslint-disable-next-line promise/prefer-await-to-then\n          resolvedPromise.then(flushJobs);\n      }\n  }\n  function queuePostFlushCb(cb) {\n      if (!activePostFlushCbs ||\n          !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {\n          pendingPostFlushCbs.push(cb);\n      }\n  }\n  function flushPostFlushCbs() {\n      if (pendingPostFlushCbs.length > 0) {\n          activePostFlushCbs = [...new Set(pendingPostFlushCbs)];\n          pendingPostFlushCbs.length = 0;\n          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n              const cb = activePostFlushCbs[postFlushIndex];\n              if (cb.active !== false)\n                  cb();\n          }\n          activePostFlushCbs = null;\n          postFlushIndex = 0;\n      }\n  }\n  function flushJobs(seen) {\n      isFlushPending = false;\n      isFlushing = true;\n      // Conditional usage of checkRecursiveUpdate must be determined out of\n      // try ... catch block since Rollup by default de-optimizes treeshaking\n      // inside try-catch. This can leave all warning code unshaked. Although\n      // they would get eventually shaken by a minifier like terser, some minifiers\n      // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\n      const check = /* istanbul ignore next -- @preserve  */ NOOP;\n      try {\n          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n              const job = queue[flushIndex];\n              if (job.active !== false) {\n                  /* istanbul ignore if -- @preserve  */\n                  if (__DEV__ && check(job)) ;\n                  job();\n              }\n          }\n      }\n      finally {\n          flushIndex = 0;\n          queue.length = 0;\n          isFlushing = false;\n      }\n  }\n\n  // Simple effect.\n  function watchEffect(effect, options) {\n      return doWatch(effect, null, options);\n  }\n  function watchPostEffect(effect, options) {\n      return doWatch(effect, null, /* istanbul ignore next -- @preserve */ { flush: \"post\" });\n  }\n  function watchSyncEffect(effect, options) {\n      return doWatch(effect, null, /* istanbul ignore next -- @preserve */ { flush: \"sync\" });\n  }\n  // Initial value for watchers to trigger on undefined initial values\n  const INITIAL_WATCHER_VALUE = {};\n  // Implementation\n  function watch(source, cb, options) {\n      return doWatch(source, cb, options);\n  }\n  // eslint-disable-next-line complexity\n  function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = {}) {\n      if (cb && once) {\n          const _cb = cb;\n          cb = (...args) => {\n              _cb(...args);\n              unwatch();\n          };\n      }\n      const reactiveGetter = (source) => deep === true\n          ? source // Traverse will happen in wrapped getter below\n          : // For deep: false, only traverse root-level properties\n              traverse(source, deep === false ? 1 : undefined);\n      let getter;\n      let forceTrigger = false;\n      let isMultiSource = false;\n      if (isRef(source)) {\n          getter = () => source.value;\n          forceTrigger = isShallow(source);\n      }\n      else if (isReactive(source)) {\n          getter = () => reactiveGetter(source);\n          forceTrigger = true;\n      }\n      else if (isArray(source)) {\n          isMultiSource = true;\n          forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n          getter = () => source.map((s) => {\n              if (isRef(s)) {\n                  return s.value;\n              }\n              if (isReactive(s)) {\n                  return reactiveGetter(s);\n              }\n              if (isFunction(s)) {\n                  return s();\n              }\n              return undefined;\n          });\n      }\n      else if (isFunction(source)) {\n          if (cb) {\n              // Getter with cb\n              getter = () => source();\n          }\n          else {\n              // No cb -> simple effect\n              getter = () => {\n                  if (cleanup) {\n                      cleanup();\n                  }\n                  return source(onCleanup);\n              };\n          }\n      }\n      else {\n          getter = NOOP;\n      }\n      if (cb && deep) {\n          const baseGetter = getter;\n          getter = () => traverse(baseGetter());\n      }\n      let cleanup;\n      const onCleanup = (fn) => {\n          // eslint-disable-next-line no-multi-assign\n          cleanup = effect.onStop = () => {\n              fn();\n              // eslint-disable-next-line no-multi-assign\n              cleanup = effect.onStop = undefined;\n          };\n      };\n      let oldValue = isMultiSource\n          ? Array.from({ length: source.length }).fill(INITIAL_WATCHER_VALUE)\n          : INITIAL_WATCHER_VALUE;\n      const job = () => {\n          if (!effect.active || !effect.dirty) {\n              return;\n          }\n          if (cb) {\n              // Watch(source, cb)\n              const newValue = effect.run();\n              if (deep ||\n                  forceTrigger ||\n                  (isMultiSource\n                      ? newValue.some((v, i) => hasChanged(v, oldValue[i]))\n                      : hasChanged(newValue, oldValue))) {\n                  // Cleanup before running cb again\n                  if (cleanup) {\n                      cleanup();\n                  }\n                  cb(newValue, \n                  // Pass undefined as the old value when it's changed for the first time\n                  oldValue === INITIAL_WATCHER_VALUE\n                      ? undefined\n                      : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE\n                          ? []\n                          : oldValue, onCleanup);\n                  oldValue = newValue;\n              }\n          }\n          else {\n              // WatchEffect\n              effect.run();\n          }\n      };\n      // Important: mark the job as a watcher callback so that scheduler knows\n      // it is allowed to self-trigger\n      job.allowRecurse = Boolean(cb);\n      let scheduler;\n      if (flush === \"sync\") {\n          scheduler = job; // The scheduler function gets called directly\n      }\n      else if (flush === \"post\") {\n          scheduler = () => {\n              queuePostFlushCb(job);\n          };\n      }\n      else {\n          scheduler = () => {\n              queueJob(job);\n          };\n      }\n      const effect = new ReactiveEffect(getter, NOOP, scheduler);\n      const scope = getCurrentScope();\n      const unwatch = () => {\n          effect.stop();\n          if (scope) {\n              // @ts-expect-error\n              remove(scope.effects, effect);\n          }\n      };\n      // Initial run\n      if (cb) {\n          if (immediate) {\n              job();\n          }\n          else {\n              oldValue = effect.run();\n          }\n      }\n      else {\n          effect.run();\n      }\n      return unwatch;\n  }\n  function traverse(value, depth = Number.POSITIVE_INFINITY, seen) {\n      if (depth <= 0 || !isObject(value) || value[ReactiveFlags.SKIP]) {\n          return value;\n      }\n      seen = seen || new Set();\n      if (seen.has(value)) {\n          return value;\n      }\n      seen.add(value);\n      depth--;\n      /* istanbul ignore else -- @preserve  */\n      if (isRef(value)) {\n          traverse(value.value, depth, seen);\n      }\n      else if (isArray(value)) {\n          for (let i = 0; i < value.length; i++) {\n              traverse(value[i], depth, seen);\n          }\n      }\n      else if (isSet(value) || isMap(value)) {\n          value.forEach((v) => {\n              traverse(v, depth, seen);\n          });\n      }\n      else if (isPlainObject(value)) {\n          // eslint-disable-next-line guard-for-in\n          for (const key in value) {\n              traverse(value[key], depth, seen);\n          }\n          for (const key of Object.getOwnPropertySymbols(value)) {\n              if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n                  traverse(value[key], depth, seen);\n              }\n          }\n      }\n      return value;\n  }\n\n  function deepToRaw(x) {\n      if (isSimpleValue(x) || isFunction(x)) {\n          return x;\n      }\n      if (isRef(x)) {\n          return deepToRaw(x.value);\n      }\n      if (isProxy(x)) {\n          return deepToRaw(toRaw(x));\n      }\n      if (isArray(x)) {\n          return x.map((item) => deepToRaw(item));\n      }\n      if (isPlainObject(x)) {\n          const obj = {};\n          Object.keys(x).forEach((key) => {\n              obj[key] = deepToRaw(x[key]);\n          });\n          return obj;\n      }\n      throw new TypeError(`${getType(x)} value is not supported`);\n  }\n  function deepWatch(instance, key, value) {\n      if (!isObject(value)) {\n          return;\n      }\n      watch(isRef(value) ? value : () => value, () => {\n          instance.setData({ [key]: deepToRaw(value) }, flushPostFlushCbs);\n      }, {\n          deep: true,\n      });\n  }\n\n  let _currentPage = null;\n  let _currentComponent = null;\n  const methodEmit = (instance, options, lifetimesKey, ...args) => {\n      if (options && options[lifetimesKey]) {\n          options[lifetimesKey](...args);\n      }\n      if (!instance[`$${lifetimesKey}`]) {\n          return;\n      }\n      const eventBackMap = {\n          onLoad: \"onUnload\",\n          onShow: \"onHide\",\n          attached: \"detached\",\n      };\n      const lifetimesBackKey = eventBackMap[lifetimesKey];\n      instance[`$${lifetimesKey}`].forEach((fn) => {\n          // 反面有没有对应的off\n          if (lifetimesBackKey) {\n              const backFn = instance[`$${lifetimesBackKey}`] &&\n                  instance[`$${lifetimesBackKey}`].find((x) => x.front === fn);\n              if (backFn) {\n                  backFn();\n              }\n          }\n          const off = fn.apply(instance, args);\n          // 调用是否返回函数，用于销毁\n          if (lifetimesBackKey && typeof off === \"function\") {\n              let backFn = instance[`$${lifetimesBackKey}`] &&\n                  instance[`$${lifetimesBackKey}`].find((x) => x.front === fn);\n              if (!backFn) {\n                  off.front === fn;\n                  if (!instance[`$${lifetimesBackKey}`]) {\n                      instance[`$${lifetimesBackKey}`] = [];\n                  }\n                  instance[`$${lifetimesBackKey}`].push(off);\n              }\n          }\n      });\n  };\n  const methodOnce = (instance, options, lifetimesKey, ...args) => {\n      if (options && options[lifetimesKey]) {\n          return options[lifetimesKey](...args);\n      }\n      if (!instance[`$${lifetimesKey}`]) {\n          return;\n      }\n      if (instance[`$${lifetimesKey}`].length) {\n          throw new Error(`一个page只能配置一个${lifetimesKey}`);\n      }\n      return instance[`$${lifetimesKey}`][0].apply(instance, args);\n  };\n  const methodOn = (instance, lifetimesKey, hook) => {\n      if (!instance) {\n          return;\n      }\n      if (!instance[`$${lifetimesKey}`]) {\n          instance[`$${lifetimesKey}`] = [];\n      }\n      instance[`$${lifetimesKey}`].push(hook);\n  };\n  // type PageQueriesConfigObject = {\n  //   type: PageQueriesType;\n  //   formatter?: (val: string | undefined) => any;\n  // };\n  // type PageQueriesConfig = PageQueriesConfigObject | PageQueriesType;\n  const createQuery = (query, queries) => {\n      if (!queries) {\n          return query;\n      }\n      let rtv = {};\n      for (let key in query) {\n          if (key in queries) {\n              const val = query[key];\n              const config = queries[key];\n              if (!config) {\n                  rtv[key] = val;\n                  break;\n              }\n              const type = config.type || config;\n              const formatter = (val) => {\n                  if (\"formatter\" in config && config.formatter !== undefined) {\n                      return config.formatter(val);\n                  }\n                  if (type === Boolean) {\n                      return !!val;\n                  }\n                  if (type === Number) {\n                      return Number(val);\n                  }\n                  if (type === Object) {\n                      return val ? JSON.parse(decodeURIComponent(val)) : {};\n                  }\n                  if (type === Array) {\n                      return val ? JSON.parse(decodeURIComponent(val)) : [];\n                  }\n                  if (type === null) {\n                      return val;\n                  }\n                  console.error(\"未知的·type·\", type);\n                  return val;\n              };\n              rtv[key] = formatter(val);\n              // 对数据转换\n          }\n          else {\n              rtv[key] = query[key];\n          }\n      }\n      return rtv;\n  };\n  /**\n   * 创建页面并关联生命周期函数\n   * @param hook - Hook 函数或包含 setup 的对象\n   */\n  const definePage = (hook) => {\n      if (!hook) {\n          return Page({});\n      }\n      let options = {};\n      if (typeof hook !== \"function\") {\n          const { setup, ...other } = hook;\n          options = other || {};\n          hook = setup;\n      }\n      if (!hook) {\n          return Page(options);\n      }\n      Page({\n          ...options,\n          // 生命周期回调函数\n          onLoad(query) {\n              _currentPage = this;\n              this.$scope = effectScope();\n              this.$query = createQuery(query, options.queries);\n              this.$context = {};\n              this.$scope.run(() => {\n                  const bindings = hook.call(this, this.$query, this.$context);\n                  if (bindings !== undefined) {\n                      Object.keys(bindings).forEach((key) => {\n                          const value = bindings[key];\n                          if (isFunction(value)) {\n                              this[key] = value;\n                              return;\n                          }\n                          this.setData({ [key]: deepToRaw(value) });\n                          deepWatch(this, key, value);\n                      });\n                  }\n                  methodEmit(this, options, \"onLoad\", query);\n              });\n              _currentPage = null;\n          },\n          onShow() {\n              methodEmit(this, options, \"onShow\");\n          },\n          onReady() {\n              methodEmit(this, options, \"onReady\");\n          },\n          onHide() {\n              methodEmit(this, options, \"onHide\");\n          },\n          onUnload() {\n              methodEmit(this, options, \"onUnload\");\n              if (this.$scope) {\n                  this.$scope.stop();\n              }\n              // 手动销毁\n              Object.keys(this).forEach((key) => {\n                  try {\n                      delete this[key];\n                  }\n                  catch (ex) {\n                      console.error(\"销毁异常\", ex);\n                  }\n              });\n          },\n          onRouteDone() {\n              methodEmit(this, options, \"onRouteDone\");\n          },\n          // 页面事件处理函数\n          onPullDownRefresh() {\n              methodEmit(this, options, \"onPullDownRefresh\");\n          },\n          onReachBottom() {\n              methodEmit(this, options, \"onReachBottom\");\n          },\n          onPageScroll(event) {\n              methodEmit(this, options, \"onPageScroll\", event);\n          },\n          onAddToFavorites(object) {\n              return methodOnce(this, options, \"onAddToFavorites\", object);\n          },\n          onShareAppMessage(event) {\n              return methodOnce(this, options, \"onShareAppMessage\", event);\n          },\n          onShareTimeline() {\n              return methodOnce(this, options, \"onShareTimeline\");\n          },\n          onResize(event) {\n              methodEmit(this, options, \"onResize\", event);\n          },\n          onTabItemTap(object) {\n              methodEmit(this, options, \"onTabItemTap\", object);\n          },\n          onSaveExitState() {\n              methodEmit(this, options, \"onSaveExitState\");\n          },\n      });\n  };\n  const usePage = () => {\n      return _currentPage;\n  };\n  const onLoad = (hook) => methodOn(usePage(), \"onLoad\", hook);\n  const onShow = (hook) => methodOn(usePage(), \"onShow\", hook);\n  const onReady = (hook) => methodOn(usePage(), \"onReady\", hook);\n  const onHide = (hook) => methodOn(usePage(), \"onHide\", hook);\n  const onUnload = (hook) => methodOn(usePage(), \"onUnload\", hook);\n  const onRouteDone = (hook) => methodOn(usePage(), \"onRouteDone\", hook);\n  const onPullDownRefresh = (hook) => methodOn(usePage(), \"onPullDownRefresh\", hook);\n  const onReachBottom = (hook) => methodOn(usePage(), \"onReachBottom\", hook);\n  const onPageScroll = (hook) => methodOn(usePage(), \"onPageScroll\", hook);\n  const onAddToFavorites = (hook) => methodOn(usePage(), \"onAddToFavorites\", hook);\n  const onShareAppMessage = (hook) => methodOn(usePage(), \"onShareAppMessage\", hook);\n  const onShareTimeline = (hook) => methodOn(usePage(), \"onShareTimeline\", hook);\n  const onResize = (hook) => methodOn(usePage(), \"onResize\", hook);\n  const onTabItemTap = (hook) => methodOn(usePage(), \"onTabItemTap\", hook);\n  const onSaveExitState = (hook) => methodOn(usePage(), \"onSaveExitState\", hook);\n  /**\n   * 创建组件并关联生命周期函数\n   * @param hook - Hook 函数或包含 setup 的对象\n   */\n  const defineComponent = (hook) => {\n      if (!hook) {\n          return Component({});\n      }\n      let options = {};\n      if (typeof hook !== \"function\") {\n          const { setup, ...other } = hook;\n          options = other;\n          hook = setup;\n      }\n      if (!hook) {\n          return Component(options);\n      }\n      let properties = null;\n      if (options.properties) {\n          properties = Object.keys(options.properties);\n      }\n      if (properties) {\n          if (options.observers === undefined) {\n              options.observers = {};\n          }\n          properties.forEach((property) => {\n              //@ts-expect-error 不要报错\n              const originObserver = options.observers[property];\n              //@ts-expect-error 不要报错\n              options.observers[property] = function (value) {\n                  // Observer executes before attached\n                  if (this.$props) {\n                      //@ts-expect-error 不要报错\n                      this.$props[property] = value;\n                  }\n                  if (originObserver !== undefined) {\n                      originObserver.call(this, value);\n                  }\n              };\n          });\n      }\n      Component({\n          ...options,\n          lifetimes: {\n              attached() {\n                  _currentComponent = this;\n                  //@ts-expect-error 增加作用域\n                  this.$scope = effectScope();\n                  const rawProps = {};\n                  if (properties) {\n                      properties.forEach((property) => {\n                          rawProps[property] = this.data[property];\n                      });\n                  }\n                  //@ts-expect-error 增加的props\n                  this.$props = shallowReactive(rawProps);\n                  // this.$props = shallowReactive(\n                  //   new Proxy(this.properties, {\n                  //     set: (target, key, value, receiver) => {\n                  //       this.setData({\n                  //         [key]: value,\n                  //       });\n                  //       // 发送自定义事件，传递数据\n                  //       this.triggerEvent(key as string, { value });\n                  //       return Reflect.set(target, key, value, receiver);\n                  //     },\n                  //   })\n                  // );\n                  //@ts-expect-error 增加context\n                  this.$context = {\n                      emit: (key, value) => {\n                          this.triggerEvent(key, { value });\n                      },\n                  };\n                  //@ts-expect-error 增加作用域\n                  this.$scope.run(() => {\n                      //@ts-expect-error 不要报错\n                      const bindings = hook.call(this, this.$props, this.$context);\n                      if (bindings !== undefined) {\n                          Object.keys(bindings).forEach((key) => {\n                              const value = bindings[key];\n                              if (isFunction(value)) {\n                                  this[key] = value;\n                                  return;\n                              }\n                              this.setData({ [key]: deepToRaw(value) });\n                              deepWatch(this, key, value);\n                          });\n                      }\n                      methodEmit(this, options, \"attached\");\n                  });\n                  _currentComponent = null;\n              },\n              ready() {\n                  methodEmit(this, options, \"ready\");\n              },\n              moved() {\n                  methodEmit(this, options, \"moved\");\n              },\n              detached() {\n                  methodEmit(this, options, \"detached\");\n                  if (this.$scope) {\n                      //@ts-expect-error 增加作用域\n                      this.$scope.stop();\n                  }\n                  // 手动销毁\n                  Object.keys(this).forEach((key) => {\n                      try {\n                          delete this[key];\n                      }\n                      catch (ex) {\n                          console.error(\"销毁异常\", ex);\n                      }\n                  });\n              },\n              error(err) {\n                  methodEmit(this, options, \"error\", err);\n              },\n          },\n      });\n  };\n  const useComponent = () => _currentComponent;\n  const attached = (hook) => methodOn(useComponent(), \"attached\", hook);\n  const ready = (hook) => methodOn(useComponent(), \"ready\", hook);\n  const moved = (hook) => methodOn(useComponent(), \"moved\", hook);\n  const detached = (hook) => methodOn(useComponent(), \"detached\", hook);\n  const error = (hook) => methodOn(useComponent(), \"error\", hook);\n\n  exports.EffectScope = EffectScope;\n  exports.ReactiveEffect = ReactiveEffect;\n  exports.attached = attached;\n  exports.computed = computed;\n  exports.customRef = customRef;\n  exports.defineComponent = defineComponent;\n  exports.definePage = definePage;\n  exports.detached = detached;\n  exports.effect = effect;\n  exports.effectScope = effectScope;\n  exports.error = error;\n  exports.getCurrentScope = getCurrentScope;\n  exports.isProxy = isProxy;\n  exports.isReactive = isReactive;\n  exports.isReadonly = isReadonly;\n  exports.isRef = isRef;\n  exports.isShallow = isShallow;\n  exports.markRaw = markRaw;\n  exports.moved = moved;\n  exports.onAddToFavorites = onAddToFavorites;\n  exports.onHide = onHide;\n  exports.onLoad = onLoad;\n  exports.onPageScroll = onPageScroll;\n  exports.onPullDownRefresh = onPullDownRefresh;\n  exports.onReachBottom = onReachBottom;\n  exports.onReady = onReady;\n  exports.onResize = onResize;\n  exports.onRouteDone = onRouteDone;\n  exports.onSaveExitState = onSaveExitState;\n  exports.onScopeDispose = onScopeDispose;\n  exports.onShareAppMessage = onShareAppMessage;\n  exports.onShareTimeline = onShareTimeline;\n  exports.onShow = onShow;\n  exports.onTabItemTap = onTabItemTap;\n  exports.onUnload = onUnload;\n  exports.proxyRefs = proxyRefs;\n  exports.reactive = reactive;\n  exports.readonly = readonly;\n  exports.ready = ready;\n  exports.ref = ref;\n  exports.shallowReactive = shallowReactive;\n  exports.shallowReadonly = shallowReadonly;\n  exports.shallowRef = shallowRef;\n  exports.stop = stop;\n  exports.toRaw = toRaw;\n  exports.toRef = toRef;\n  exports.toRefs = toRefs;\n  exports.toValue = toValue;\n  exports.triggerRef = triggerRef;\n  exports.unref = unref;\n  exports.useComponent = useComponent;\n  exports.usePage = usePage;\n  exports.watch = watch;\n  exports.watchEffect = watchEffect;\n  exports.watchPostEffect = watchPostEffect;\n  exports.watchSyncEffect = watchSyncEffect;\n\n}));\n"]}