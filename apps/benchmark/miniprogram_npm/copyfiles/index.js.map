{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar path = require('path');\nvar fs = require('fs');\nvar glob = require('glob');\nvar mkdirp = require('mkdirp');\nvar untildify = require('untildify');\nvar through = require('through2').obj;\nvar noms = require('noms').obj;\nfunction toStream(array) {\n  var length = array.length;\n  var i = 0;\n  return noms(function (done) {\n    if (i >= length) {\n      this.push(null);\n    }\n    this.push(array[i++]);\n    done();\n  });\n}\nfunction depth(string) {\n  return path.normalize(string).split(path.sep).length - 1;\n}\nfunction dealWith(inPath, up) {\n  if (!up) {\n    return inPath;\n  }\n  if (up === true) {\n    return path.basename(inPath);\n  }\n  if (depth(inPath) < up) {\n    throw new Error('cant go up that far');\n  }\n  return path.join.apply(path, path.normalize(inPath).split(path.sep).slice(up));\n}\nvar copyFile = _copyFile;\nfunction _copyFile (src, dst, opts, callback) {\n  fs.createReadStream(src)\n    .pipe(fs.createWriteStream(dst, {\n      mode: opts.mode\n    }))\n    .once('error', callback)\n    .once('finish', function () {\n      fs.chmod(dst, opts.mode, function (err) {\n        callback(err);\n      })\n    })\n}\nif (fs.copyFile) {\n  copyFile = function (src, dst, opts, callback) {\n    fs.copyFile(src, dst, callback);\n  }\n}\nfunction makeDebug(config) {\n  if (config.verbose) {\n    return function (thing) {\n      console.log(thing);\n    }\n  }\n  return function () {}\n}\nmodule.exports = copyFiles;\nfunction copyFiles(args, config, callback) {\n  if (typeof config === 'function') {\n    callback = config;\n    config = {\n      up:0\n    };\n  }\n  if (typeof config !== 'object' && config) {\n    config = {\n      up: config\n    };\n  }\n  var debug = makeDebug(config);\n  var copied = false;\n  var opts = config.up || 0;\n  var soft = config.soft;\n  if (typeof callback !== 'function') {\n    throw new Error('callback is not optional');\n  }\n  var input = args.slice();\n  var outDir = input.pop();\n  var globOpts = {};\n  if (config.exclude) {\n    globOpts.ignore = config.exclude;\n  }\n  if (config.all) {\n    globOpts.dot = true;\n  }\n  if (config.follow) {\n    globOpts.follow = true;\n  }\n  outDir = outDir.startsWith('~') ? untildify(outDir) : outDir;\n  toStream(input.map(function(srcP) {return srcP.startsWith('~') ? untildify(srcP) : srcP;}))\n  .pipe(through(function (pathName, _, next) {\n    var self = this;\n    glob(pathName, globOpts, function (err, paths) {\n      if (err) {\n        return next(err);\n      }\n      paths.forEach(function (unglobbedPath) {\n        debug(`unglobed path: ${unglobbedPath}`);\n        self.push(unglobbedPath);\n      });\n      next();\n    });\n  }))\n  .on('error', callback)\n  .pipe(through(function (pathName, _, next) {\n    fs.stat(pathName, function (err, pathStat) {\n      if (err) {\n        return next(err);\n      }\n      var outName = path.join(outDir, dealWith(pathName, opts));\n      function done(){\n        mkdirp(path.dirname(outName)).then(()=>{\n          next(null, {\n            pathName: pathName,\n            pathStat: pathStat\n          });\n        }, next);\n      }\n      if (pathStat.isDirectory()) {\n        debug(`skipping, is directory: ${pathName}`)\n        return next();\n      }\n      if (!pathStat.isFile()) {\n        return next(new Error('how can it be neither file nor folder?'))\n      }\n      if (!soft) {\n        return done();\n      }\n      fs.stat(outName, function(err){\n        if(!err){\n          //file exists\n          return next()\n        }\n        if (err.code === 'ENOENT') {\n          //file does not exist\n          return done();\n        }\n        // other error\n        return next(err)\n      })\n    });\n  }))\n  .on('error', callback)\n  .pipe(through(function (obj, _, next) {\n\n    if (!copied) {\n      copied = true;\n    }\n    var pathName = obj.pathName;\n    var pathStat = obj.pathStat;\n    var outName = path.join(outDir, dealWith(pathName, opts));\n    debug(`copy from: ${pathName}`)\n    debug(`copy to: ${outName}`)\n    copyFile(pathName, outName, pathStat, next)\n  }))\n  .on('error', callback)\n  .on('finish', function () {\n    if (config.error && !copied) {\n      return callback(new Error('nothing coppied'));\n    }\n    callback();\n  });\n}\n"]}