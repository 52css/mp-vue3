{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar Readable = require('readable-stream').Readable;\nvar inherits = require('inherits');\ninherits(Noms, Readable);\nfunction Noms (options) {\n  Readable.call(this,options);\n  this.inProgress = false;\n  this.lastPush = void 0;\n  this.started = false;\n  this.errored = false;\n}\nNoms.prototype.push = function(chunk, encoding) {\n      this.lastPush = Readable.prototype.push.call(this, chunk, encoding);\n      return this.lastPush;\n  };\nNoms.prototype.nom = function (callback) {\n  callback(null, null);\n};\nNoms.prototype._read = function (size) {\n  if (this.inProgress || this.errored) {\n    return;\n  }\n  if (this.started === false) {\n    this.inProgress = true;\n    this.callStart(size);\n    return;\n  }\n  this.inProgress = true;\n  this.callRead(size);\n};\nNoms.prototype._before = function (next) {\n  next();\n};\nNoms.prototype.callRead = function (size) {\n  var useSize = this.nom.length > 1;\n  // so if nothing is pushed, we'll go agian\n  this.lastPush = true;\n  var self = this;\n  function cb(err, chunk) {\n    if (err) {\n      self.errored = true;\n      self.inProgress = false;\n      self.emit('error', err);\n      return;\n    }\n    if (chunk !== undefined) {\n      self.push(chunk);\n    }\n    if (self.lastPush) {\n      return self.callRead(size);\n    } else {\n      self.inProgress = false;\n    }\n  }\n  if (useSize) {\n    this.nom(size, cb);\n  } else {\n     this.nom(cb);\n  }\n};\nNoms.prototype.callStart = function (size) {\n  var self = this;\n  function cb(err, chunk) {\n    self.started = true;\n    if (err) {\n      self.errored = true;\n      self.inProgress = false;\n      self.emit('error', err);\n      return;\n    }\n    if (chunk !== undefined) {\n      self.push(chunk);\n    }\n    self.callRead(size);\n  }\n  this._before(cb);\n};\nfunction ctor(read, before) {\n  inherits(YourStream, Noms);\n  function YourStream (opts) {\n    Noms.call(this, opts);\n  }\n  YourStream.prototype.nom = read;\n  if (typeof before === 'function') {\n    YourStream.prototype._before = before;\n  }\n  return YourStream;\n}\nmodule.exports = exports = function(options, read, before) {\n  if (typeof options === 'function') {\n    before = read;\n    read = options;\n    options = {};\n  }\n  return new (ctor(read, before))(options);\n};\nexports.ctor = ctor;\nexports.obj = function(options, read, before) {\n  var out = {};\n  if (typeof options === 'function') {\n    before = read;\n    read = options;\n    options = undefined;\n  }\n  options = options || {};\n  Object.keys(options).forEach(function (key) {\n    out[key] = options[key];\n  });\n  out.objectMode = true;\n  return new (ctor(read, before))(out);\n};"]}